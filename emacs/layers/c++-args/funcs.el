(defun tk/beginning-of-args ()
  (unless (looking-back "(")
    (cond ((looking-at "(") nil)
          ((looking-back ");?") (forward-list -1))
          (t (progn (forward-char)
                    (c-beginning-of-defun))))
    (search-forward "(")))

(defmacro tk/do-args (&rest body)
  `(while (progn (search-forward-regexp "[<>{}(),]")
                 (or (not (string= (match-string 0) ")"))
                     (c-in-literal)))
     (unless (c-in-literal)
       (cond ((string-match "[<({]" (match-string 0)) (forward-char -1) (forward-list))
             ((string= (match-string 0) ",") ,@body)))))

(defun tk/backward-arg-1 ()
  (let ((r (point)))
    (skip-chars-backward " \t\n")
    (when (looking-back ",")
      (forward-char -1))
    (while
        (progn
          (search-backward-regexp "[<>{}(),]" nil t)
          (or (not (string-match "[{(<,]" (match-string 0)))
              (c-in-literal)))
      (unless (c-in-literal)
        (forward-char)
        (forward-list -1)))
    (search-forward-regexp "[^({<,[:space:]\n]")
    (forward-char -1)
    (not (equal r (point)))))

(defun tk/forward-arg-1 ()
  (let ((r (point)))
    (when (looking-at ",")
      (forward-char))
    (while
        (progn
          (search-forward-regexp "[<>{}(),]" nil t)
          (or (not (string-match "[})>,]" (match-string 0)))
              (c-in-literal)))
      (unless (c-in-literal)
        (forward-char -1)
        (forward-list)))
    (forward-char -1)
    (not (equal r (point)))))

(defun tk/forward-arg (&optional arg)
  (interactive "p")
  (or arg (setq arg 1))
  (while (> arg 0)
    (setq arg (- arg 1))
    (tk/forward-arg-1))
  (while (< arg 0)
    (setq arg (+ arg 1))
    (tk/backward-arg-1)))

(defun tk/backward-arg (&optional arg)
  (interactive "p")
  (or arg (setq arg 1))
  (tk/forward-arg (- arg)))

(defun tk/beginning-of-arg-p ()
  (and (looking-back "[{(<,][[:space:]\n]*")
       (not (c-in-literal))))

(defun tk/end-of-arg-p ()
  (and (looking-at "[[:space:]\n]*[})>,]")
       (not (c-in-literal))))

(defun tk/first-arg-p ()
  (save-excursion
    (unless (tk/beginning-of-arg-p)
      (tk/backward-arg-1))
    (and (looking-back "[({<][[:space:]\n]*")
         (not (c-in-literal)))))

(defun tk/last-arg-p ()
  (save-excursion
    (unless (tk/end-of-arg-p)
      (tk/forward-arg-1))
    (and (looking-at "[[:space:]\n]*[)}>]")
         (not (c-in-literal)))))

(defun tk/kill-arg (arg)
  (interactive "p")
  (save-excursion
    (if (tk/beginning-of-arg-p)
        (skip-chars-forward " \t\n")
      (tk/backward-arg-1))
    (if (tk/last-arg-p)
        (kill-region (progn (if (tk/backward-arg-1)
                                (tk/forward-arg-1))
                            (point))
                     (progn (tk/forward-arg arg)
                            (point)))
      (kill-region (point)
                   (progn (tk/forward-arg arg)
                          (if (tk/forward-arg-1)
                              (tk/backward-arg-1))
                          (point))))))

(defun tk/transpose-arg (arg)
  (interactive "*p")
  (transpose-subr 'tk/forward-arg arg))

(defun tk/multiline-wf-args ()
  (interactive)
  (save-excursion
    (tk/beginning-of-args)
    (unless (looking-at ")") (newline-and-indent))
    (tk/do-args (newline-and-indent))))

(defun tk/inline-wf-args ()
  (interactive)
  (save-excursion
    (tk/beginning-of-args)
    (tk/do-args (save-excursion (delete-indentation)))
    (unless (looking-back "()") (delete-indentation))))

(defun tk/line-wf-args-switch ()
  (interactive)
  (let (b e)
    (save-excursion
      (tk/beginning-of-args)
      (setq b (line-number-at-pos))
      (forward-char -1)
      (forward-list)
      (setq e (line-number-at-pos)))
    (if (equal b e)
        (tk/multiline-wf-args)
      (tk/inline-wf-args))))

(defun tk/comment-dwim-arg ()
  (interactive)
  (let ((comment-start "/* ") (comment-end " */"))
    (call-interactively 'comment-dwim)))
